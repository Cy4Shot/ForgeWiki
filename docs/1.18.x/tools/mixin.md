# Forge 1.18.x Tools - Mixins

**Mixin** is a method to modify Minecraft's code, or even Forge and other mods.
This tutorial will help you setup mixin, and show you how to use it.

!!! warning "Mixin is dangerous!"

    Mixing into Minecraft code is dangerous! It can cause crashes and incompatabilities. Only use it as a last resort.

## 1. Mixin Setup
The first step is to add the mixin **plugin**.
We can do this by adding mixin as a *buildscript dependency* in our `build.gradle` file.

Begin by modifying the `buildscript` section at the top of the `build.gradle` file to look like this:
``` groovy title="Adding the mixin plugin." linenums="1"
buildscript {
    repositories {
        maven { url = 'https://maven.minecraftforge.net/' }
        maven { url = 'https://repo.spongepowered.org/repository/maven-public/' } //(1)!
    }
    dependencies {
        classpath group: 'net.minecraftforge.gradle', name: 'ForgeGradle', version: '5.1.+', changing: true
        classpath group: 'org.spongepowered', name: 'mixingradle', version: '0.7-SNAPSHOT' //(2)!
    }
}

apply plugin: 'net.minecraftforge.gradle'
apply plugin: 'org.spongepowered.mixin' //(3)!
```

1. The URL tells the buildscript where to look for mixin plugin!
2. Specify the name and version of the package we are downloading from the URL!
3. Apply the plugin itself!

<br />
Now, we need to add a **mixin** section to the buildscript, that points to our *config file* and *refmap*.

- The config file points to the active mixins.
- The refmap is an autogenerated file that allows your changes to persist across different minecraft installations!

Lets add that:
``` groovy title="Add required mixin files." linenums="1"
mixin {
    add sourceSets.main, "modid.refmap.json" //(1)!
    config "modid.mixins.json"
}
```

1. Make sure to replace `modid` with your Mod ID!

<br/>
The last modification to our `build.gradle` file involves the addition of an **annotation processor**.
You can do this by adding it to your `dependencies` section of the `build.gradle` file:
``` groovy title="The annotation processor" linenums="1"
dependencies {
    annotationProcessor 'org.spongepowered:mixin:0.8.5:processor'
}
```

<br/>

Finally, you can create your `modid.mixins.json` file, inside the `src/main/resources/` folder:

```json title="Mixin Config File" linenums="1"
{
	"required": true,
	"package": "your.package.name.mixin",
	"compatibilityLevel": "JAVA_17",
	"refmap": "modid.refmap.json",
	"mixins": [
	],
	"client": [
	],
	"minVersion": "0.8"
}
```
<div class="result" markdown>
Make sure to replace `your.package.name.mixin` with the path to the package containing all of your mixins, and `modid` with your Mod ID!
</div>

## 2. Writing Mixins

To declare a Mixin, simply add the `#!java @Mixin(MixinTarget.class)` annotation to the top of your mixin class.
For example, if I wanted to inject some code into an item entity, I would write:
```java title="Mixin Annotation" linenums="1"
@Mixin(ItemEntity.class)
public class MixinItemEntity {
}
```

We now need to add the **class name** of the mixin to our config:

```json linenums="1" hl_lines="7"
{
	"required": true,
	"package": "your.package.name.mixin",
	"compatibilityLevel": "JAVA_17",
	"refmap": "modid.refmap.json",
	"mixins": [
		"MixinItemEntity"
	],
	"client": [
	],
	"minVersion": "0.8"
}
```

!!! info "Client vs Server Mixins"

    Any mixins only present on the client should go in the **client** section of the mixin config file.
    Otherwise, they should go in the **mixins** section.

### 2.1 Injects
The next step depends on the code that will be modified.
In this example, I want to make Item entities indestructible *(e.g. by fire)*.
So, the method I want to override in the `ItemEntity` class is `attackEntityFrom(DamageSource, float)`.
Hence, I will add this method to the mixin class.

Don't panic, I'll explain this in a bit: 

```java title="Method Inject" linenums="1"
@Mixin(ItemEntity.class)
public class MixinItemEntity {
    @Inject(at = @At("HEAD"), method = "attackEntityFrom(Lnet/minecraft/util/DamageSource;F)Z", cancellable = true)
    private void attackEntityFrom(DamageSource source, float amount, CallbackInfoReturnable<Boolean> callback) {
        callback.setReturnValue(false);
    }
}
```

The `#!java @Inject` annotation allows you to **inject** code to run inside a function. It takes 3 parameters:

- `method`: The method signature to mixin to. *See [`Method Signatures`](#3-method-signatures "Learn how to write method signatures!").*
- `at`: The point at which to inject code.
- `cancellable` *(optional)*: Whether this function can be cancelled.

Let's break it down further.

The `at` parameter takes an annotation `#!java @At` into which is passed a string. This can be one of many **injection point references**:

| IPR | Description |
|--:|---|
|`HEAD`|At the **top** of the method.|
|`RETURN`|Before every **return** statement.|
|`INVOKE`|When the method is **called**.|
|`TAIL`|Before the **final return** statement.|

!!! tip "Returning or Cancelling in an Inject"

    If you would like to change the return statement *(if the function returns something)*, or cancel a void method, you must set `cancellable = true`.
    It is false by default.

<br/>
The method itself is named similary to that in `ItemEntity`, and takes the same parameters, with an additional `CallbackInfo`.

- If a method does not return *(is void)*, you add a `CallbackInfo`. The method may now be cancelled with `CallbackInfo#cancel`.
- If a method is a function, you add a `#!java CallbackInfoReturnable<ReturnType>`. The method's return value may now be changed with `CallbackInfoReturnable#setReturnValue`.

### 2.2 Accessors

Accessors allow you to access variables that are **not visible** *(private or final)*.
For example, to get the `itemUseCooldown` variable in the `MinecraftClient` class:

```java title="Basic Accessor Example" linenums="1"
@Mixin(MinecraftClient.class)
public interface MinecraftClientAccessor {
    @Accessor("itemUseCooldown")
    int exampleGetter();
}
```
<div class="result" markdown>
This can now be called as follows: 
```java linenums="1"
MinecraftClient instance = MinecraftClient.getInstance();
int x = ((MinecraftClientAccessor) instance).exampleGetter();
```
</div>

Here, we are creating an `#!java @Accessor` to the `itemUseCooldown` variable.
The method name does not matter. We can also create a way to set the variable:

```java title="Accessor Setter Example" linenums="1"
@Mixin(MinecraftClient.class)
public interface MinecraftClientAccessor {
    @Accessor("itemUseCooldown")
    public void exampleSetter(int value);
}
```
<div class="result" markdown>
This can now be called as follows: 
```java linenums="1"
MinecraftClient instance = MinecraftClient.getInstance();
((MinecraftClientAccessor) instance).exampleSetter(1);
```
</div>

!!! info "Accessors to Static Fields"

    Below is an example of accessing the static `List<RegistryKey<Biome>> BIOMES` from `VanillaLayeredBiomeSource`.

    ```java linenums="1"
    @Mixin(VanillaLayeredBiomeSource.class)
    public interface VanillaLayeredBiomeSourceAccessor {
        @Accessor("BIOMES")
        public static List<RegistryKey<Biome>> getBiomes() {
            throw new AssertionError();
        }

        @Accessor("BIOMES")
        public static void setBiomes(List<RegistryKey<Biome>> biomes) {
            throw new AssertionError();
        }
    }
    ```
    <div class="result" markdown>
        <br/>
        This can now be called as follows: 
        ```java linenums="1"
        List<RegistryKey<Biome>> biomes = VanillaLayeredBiomeSourceAccessor.getBiomes();
        VanillaLayeredBiomeSourceAccessor.setBiomes(biomes);
        ```
    </div>

### 2.3 Invokers
Invokers, much like Accessors, allow you to access methods that are **not visible** *(private or final)*.

For example, if you would like to invoke the private `teleportTo()` in the `EndermanEntity` class.

```java linenums="1"
@Mixin(EndermanEntity.class)
public interface EndermanEntityInvoker {
  @Invoker("teleportTo")
  public boolean invokeTp(double x, double y, double z);
}
```
<div class="result" markdown>
This can now be called as follows: 
```java linenums="1"
EndermanEntity enderman = ...;
((EndermanEntityInvoker) enderman).invokeTp(0D, 0D, 0D);
```
</div>

!!! info "Invoking Static Methods"

    Below is an example of invoking the static `registerPotionType()` from `BrewingRecipeRegistry`.

    ```java linenums="1"
    @Mixin(BrewingRecipeRegistry.class)
    public interface BrewingRecipeRegistryInvoker {
        @Invoker("registerPotionType")
        public static void invokeRegister(Item item) {
            throw new AssertionError();
        }
    }
    ```
    <div class="result" markdown>
        <br/>
        This can now be called as follows: 
        ```java
        BrewingRecipeRegistryInvoker.invokeRegister(item);
        ```
    </div>


## 3. Method Signatures

A method signature points to a specific method in the Java code. They are written as `name(paramaters)return`:

- The `name` is the name of the function to find. For `boolean attackEntityFrom(DamageSource source, float amount)` this would be `attackEntityFrom`.
- The `parameters` are the types of parameters passed in. For `boolean attackEntityFrom(DamageSource source, float amount)` this would be `Lnet/minecraft/util/DamageSource;F`. *(See below.)*
- The `return` is the type to return. For `boolean attackEntityFrom(DamageSource source, float amount)` this would be `Z`. *(See below.)*

**Descriptors** define how to represent a type in a method signature. Primitives are defined by a letter, whereas classes are paths surrounded by `L` and `;`:

| Descriptor | Infomation |
|-----:|---|
|`B`|A `byte` type.|
|`C`|A `char` type.|
|`D`|A `double` type.|
|`F`|A `float` type.|
|`I`|A `int` type.|
|`J`|A `long` type.|
|`LClassName;`|A **typed object**. For example, `Lnet/minecraft/util/DamageSource;`.|
|`S`|A `short` type.|
|`V`|A `void` type.|
|`Z`|A `boolean` type.|
|`[Type`|An **array** of a given type. For example, `[B` or `[Lnet/minecraft/util/DamageSource;`.|

!!! warning "Mixing into Constructors"

    To inject into a constructor, use `<init>()V` as the method target, with `()` containing the constructor argument descriptors. When injecting into constructors, `#!java @At` must be set to either `TAIL` or `RETURN`. No other forms of injection are officially supported.

    To inject into a static constructor, use `<clinit>` as the method name.

## Sources

Sources used in writing this guide are:

- [`darkhax.net`](https://darkhax.net/2020/07/mixins "Visit darkhax.net!")
- [`fabricmc.net`](https://fabricmc.net/wiki/tutorial:mixin_introduction "Visit fabricmc.net!")